# -*- coding: utf-8 -*-
import time
import random
import string
import csv
import tracemalloc
import sys
import traceback
from pathlib import Path

# Agregar automáticamente la carpeta "src" al PYTHONPATH
sys.path.append(str(Path(__file__).resolve().parents[1]))

# ---------- Configuración ----------
SIZES = [100, 1000, 10000]  # Pequeño, mediano y grande
NUM_RUNS = 10
OUTPUT_CSV = "resultados_rendimiento.csv"
MEASURE_MEMORY = True
STRING_LENGTH = 20

# ---------- Importación de estructuras ----------
from tarea1.listaordenadadinamica import ListaOrdenadaDinámica
from tarea1.listaordenadaestatica import ListaOrdenadaEstática
from tarea1.tablahashabierta import TablaHashAbierta    
from tarea1.tablahash import TablaHash
from tarea1.triepunteros import TriePunteros
from tarea1.triearreglos import TrieArreglos
from tarea1.abbpunteros import AbbPunteros
from tarea1.abbvectorheap import ABBVectorHeap

# ---------- Comparaciones ----------
comparaciones = [
    ("ListaOrdenadaDinámica", lambda n: ListaOrdenadaDinámica(),
     "ListaOrdenadaEstática", lambda n: ListaOrdenadaEstática(n*2)),

    ("AbbPunteros", lambda n: AbbPunteros(),
    "ABBVectorHeap", lambda n: ABBVectorHeap(capacidad=max(2000, n * 2))),

    ("TriePunteros", lambda n: TriePunteros(),
     "TrieArreglos", lambda n: TrieArreglos()),

    ("ListaOrdenadaDinámica", lambda n: ListaOrdenadaDinámica(),
     "TablaHash", lambda n: TablaHash()),

    ("ListaOrdenadaDinámica", lambda n: ListaOrdenadaDinámica(),
     "AbbPunteros", lambda n: AbbPunteros()),

    ("ListaOrdenadaDinámica", lambda n: ListaOrdenadaDinámica(),
     "TriePunteros", lambda n: TriePunteros()),

    ("TablaHash", lambda n: TablaHash(),
     "TriePunteros", lambda n: TriePunteros())
]


# ---------- Funciones auxiliares ----------
def generar_cadenas(n, largo=STRING_LENGTH):
    """
    Genera n cadenas aleatorias (a..z) de longitud 'largo'.
    """
    abc = string.ascii_lowercase
    return [''.join(random.choices(abc, k=largo)) for _ in range(n)]


def medir_estructura(estructura, datos):
    """
    Mide inserción, búsqueda (miembro), borrado y memoria usada.
    """
    # Inserción
    if MEASURE_MEMORY:
        tracemalloc.start()
    t0 = time.perf_counter()
    for h in datos:
        estructura.inserte(h)
    t1 = time.perf_counter()
    insertar_ms = (t1 - t0) * 1000.0

    # Memoria pico (si aplica)
    memoria_kb = 0.0
    if MEASURE_MEMORY:
        current, peak = tracemalloc.get_traced_memory()
        tracemalloc.stop()
        memoria_kb = peak / 1024.0

    # Miembro (búsqueda)
    t0 = time.perf_counter()
    for h in datos[:len(datos)//2]:
        estructura.miembro(h)
    t1 = time.perf_counter()
    miembro_ms = (t1 - t0) * 1000.0

    # Borrar
    t0 = time.perf_counter()
    for h in datos[:len(datos)//4]:
        estructura.borre(h)
    t1 = time.perf_counter()
    borrar_ms = (t1 - t0) * 1000.0

    return insertar_ms, miembro_ms, borrar_ms, memoria_kb


def medir_print_done(estructura):
    """
    Mide el tiempo de 'print' y 'done' (solo para diccionarios grandes).
    """
    try:
        t0 = time.perf_counter()
        estructura.print()
        t1 = time.perf_counter()
        print_ms = (t1 - t0) * 1000.0
    except Exception:
        print_ms = float("nan")

    try:
        t0 = time.perf_counter()
        estructura.done()
        t1 = time.perf_counter()
        done_ms = (t1 - t0) * 1000.0
    except Exception:
        done_ms = float("nan")

    return print_ms, done_ms


# ---------- Escritura CSV ----------
def preparar_csv(path: str):

    """
    Crea el archivo CSV de salida con los encabezados iniciales.
    """
    p = Path(path)
    p.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w", newline="", encoding="utf-8-sig") as f:
        writer = csv.writer(f)
        writer.writerow([
            "comparacion", "estructura", "tamano", "ejecucion",
            "inserte_ms", "miembro_ms", "borre_ms",
            "print_ms", "done_ms", "memoria_pico_kb"
        ])


# ---------- Ejecución principal ----------
def pruebas_de_rendimiento():

    """
    Ejecuta todas las comparaciones de rendimiento entre estructuras de datos.
    Los resultados se guardan en un archivo CSV con tiempos y memoria medidos.
    """

    preparar_csv(OUTPUT_CSV)

    with open(OUTPUT_CSV, "a", newline="", encoding="utf-8-sig") as f:
        writer = csv.writer(f)

        for (nombre1, clase1, nombre2, clase2) in comparaciones:
            print(f"\n=== Comparación: {nombre1} vs {nombre2} ===")
            for tamano in SIZES:
                print(f"  - Tamaño: {tamano}")
                for run in range(1, NUM_RUNS + 1):
                    print(f"    • Ejecución {run}/{NUM_RUNS} ...", end="", flush=True)
                    datos = generar_cadenas(tamano)

                    # Crear instancias nuevas
                    e1 = clase1(tamano)
                    e2 = clase2(tamano)

                    # ---- Estructura 1 ----
                    try:
                        ins1, mem1, del1, mem_kb1 = medir_estructura(e1, datos)
                        print_ms1, done_ms1 = (medir_print_done(e1) if tamano == 1_000_000 else (0.0, 0.0))
                    except Exception as ex:
                        print(f"\n⚠️ Error en {nombre1}: {type(ex).__name__} -> {ex}")
                        traceback.print_exc()
                        ins1 = mem1 = del1 = mem_kb1 = print_ms1 = done_ms1 = float("nan")

                    # ---- Estructura 2 ----
                    try:
                        ins2, mem2, del2, mem_kb2 = medir_estructura(e2, datos)
                        print_ms2, done_ms2 = (medir_print_done(e2) if tamano == 1_000_000 else (0.0, 0.0))
                    except Exception as ex:
                        print(f"\n⚠️ Error en {nombre2}: {type(ex).__name__} -> {ex}")
                        traceback.print_exc()
                        ins2 = mem2 = del2 = mem_kb2 = print_ms2 = done_ms2 = float("nan")

                    # Guardar resultados
                    writer.writerow([
                        f"{nombre1} vs {nombre2}", nombre1, tamano, run,
                        f"{ins1:.3f}", f"{mem1:.3f}", f"{del1:.3f}",
                        f"{print_ms1:.3f}", f"{done_ms1:.3f}", f"{mem_kb1:.3f}"
                    ])
                    writer.writerow([
                        f"{nombre1} vs {nombre2}", nombre2, tamano, run,
                        f"{ins2:.3f}", f"{mem2:.3f}", f"{del2:.3f}",
                        f"{print_ms2:.3f}", f"{done_ms2:.3f}", f"{mem_kb2:.3f}"
                    ])
                    print(" hecho")

    print(f"\n✅ Pruebas completadas. Resultados guardados en {OUTPUT_CSV}")


# ---------- Ejecutar si se lanza este script ----------
if __name__ == "__main__":
    pruebas_de_rendimiento()
